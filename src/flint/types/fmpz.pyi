#
# It would be better if many methods accepted SupportsIndex rather than just
# int | fmpz but for now these annotations are accurate.
#

class fmpz:
    def __init__(self, arg: int | fmpz | str = 0, /): ...

    @property
    def numerator(self) -> fmpz: ...
    @property
    def denominator(self) -> fmpz: ...

    def bit_length(self) -> int: ...
    def height_bits(self, signed: bool = False) -> int: ...

    def str(self, base: int = 10, condense: int = 0) -> str: ...
    def repr(self) -> str: ...

    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

    def __int__(self) -> int: ...
    def __index__(self) -> int: ...

    def __floor__(self) -> fmpz: ...
    def __ceil__(self) -> fmpz: ...
    def __trunc__(self) -> fmpz: ...
    def __round__(self, ndigits: int | None = None) -> fmpz: ...

    def __lt__(self, other: int | fmpz, /) -> bool: ...
    def __le__(self, other: int | fmpz, /) -> bool: ...
    def __gt__(self, other: int | fmpz, /) -> bool: ...
    def __ge__(self, other: int | fmpz, /) -> bool: ...

    def __neg__(self) -> fmpz: ...
    def __pos__(self) -> fmpz: ...
    def __add__(self, other: int | fmpz, /) -> fmpz: ...
    def __radd__(self, other: int, /) -> fmpz: ...
    def __sub__(self, other: int | fmpz, /) -> fmpz: ...
    def __rsub__(self, other: int, /) -> fmpz: ...
    def __mul__(self, other: int | fmpz, /) -> fmpz: ...
    def __rmul__(self, other: int, /) -> fmpz: ...
    def __truediv__(self, other: int | fmpz, /) -> fmpz: ...
    def __rtruediv__(self, other: int, /) -> fmpz: ...
    def __floordiv__(self, other: int | fmpz, /) -> fmpz: ...
    def __rfloordiv__(self, other: int, /) -> fmpz: ...
    def __mod__(self, other: int | fmpz, /) -> fmpz: ...
    def __rmod__(self, other: int, /) -> fmpz: ...
    def __divmod__(self, other: int | fmpz, /) -> tuple[fmpz, fmpz]: ...
    def __rdivmod__(self, other: int, /) -> tuple[fmpz, fmpz]: ...
    def __pow__(self, other: int | fmpz, modulo: int | fmpz | None = None, /) -> fmpz: ...
    def __rpow__(self, other: int, modulo: int | fmpz | None = None, /) -> fmpz: ...
    def __abs__(self) -> fmpz: ...

    def __lshift__(self, other: int | fmpz, /) -> fmpz: ...
    def __rlshift__(self, other: int | fmpz, /) -> fmpz: ...
    def __rshift__(self, other: int | fmpz, /) -> fmpz: ...
    def __rrshift__(self, other: int | fmpz, /) -> fmpz: ...
    def __and__(self, other: int | fmpz, /) -> fmpz: ...
    def __rand__(self, other: int, /) -> fmpz: ...
    def __or__(self, other: int | fmpz, /) -> fmpz: ...
    def __ror__(self, other: int, /) -> fmpz: ...
    def __xor__(self, other: int | fmpz, /) -> fmpz: ...
    def __rxor__(self, other: int, /) -> fmpz: ...
    def __invert__(self) -> fmpz: ...

    def gcd(self, other: int | fmpz, /) -> fmpz: ...
    def lcm(self, other: int | fmpz, /) -> fmpz: ...
    def factor(self, trial_limit: int | None = None) -> list[tuple[fmpz, int]]: ...
    def factor_smooth(self, bits: int = 15, proved: int = -1): ...

    def is_prime(self) -> bool: ...
    def is_probable_prime(self) -> bool: ...
    def is_square(self) -> bool: ...
    def is_perfect_power(self) -> bool: ...

    def partitions_p(self) -> fmpz: ...
    def moebius_mu(self) -> fmpz: ...
    def fac_ui(self) -> fmpz: ...
    def primorial_ui(self) -> fmpz: ...
    def fib_ui(self) -> fmpz: ...
    def rising(self, n: int) -> fmpz: ...

    @classmethod
    def bin_uiui(cls, n: int, k: int) -> fmpz: ...
    @classmethod
    def bell_number(cls, n: int) -> fmpz: ...
    @classmethod
    def euler_number(cls, n: int) -> fmpz: ...
    @classmethod
    def stirling_s1(cls, n: int, k: int) -> fmpz: ...
    @classmethod
    def stirling_s2(cls, n: int, k: int) -> fmpz: ...

    def divisor_sigma(self, k: int) -> fmpz: ...
    def euler_phi(self) -> fmpz: ...

    def isqrt(self) -> fmpz: ...
    def sqrt(self) -> fmpz: ...
    def sqrtrem(self) -> tuple[fmpz, fmpz]: ...
    def sqrtmod(self, p: int | fmpz) -> fmpz: ...
    def root(self, n: int) -> fmpz: ...

    def jacobi(self, other: int | fmpz, /) -> int: ...
