#
#
#
from typing import (
    TYPE_CHECKING,
    Protocol,
    TypeVar,
    Iterator,
    Iterable,
    Any,
    Self,
    Mapping,
    Sequence,
    overload,
)

from .flint_base.flint_base import (
    flint_elem,
    flint_scalar,
    flint_poly,
    flint_mpoly,
    flint_mpoly_context,
    flint_series,
    Ordering,
)

from flint.types.fmpz import fmpz

__all__ = [
    # Abstract base classes
    "flint_elem",
    "flint_scalar",
    "flint_poly",
    "flint_mpoly",
    "flint_mpoly_context",
    "flint_series",
    # Protocols
    "elem_p",
    "scalar_p",
    "poly_p",
    "mpoly_p",
    "mpoly_context_p",
    "series_p",
    # Types
    "Ordering",
    "fmpz",
    "ifmpz",
]


if TYPE_CHECKING:
    import flint as _flint


_Telem = TypeVar("_Telem", bound=flint_scalar)
_Telem_co = TypeVar("_Telem_co", bound=flint_scalar, covariant=True)
_Telem_coerce = TypeVar("_Telem_coerce")
_Telem_coerce_contra = TypeVar("_Telem_coerce_contra", contravariant=True)
_Tmpoly = TypeVar("_Tmpoly", bound=flint_mpoly, covariant=True)
_Tctx = TypeVar("_Tctx", bound=flint_mpoly_context)
_Sctx = TypeVar("_Sctx", bound=flint_mpoly_context)

_str = str


ifmpz = fmpz | int


class elem_p(Protocol):
    """FLINT element Protocol."""
    def str(self) -> _str: ...
    def repr(self) -> _str: ...


class scalar_p(elem_p, Protocol):
    """FLINT scalar Protocol."""
    def is_zero(self) -> bool: ...
    def __pos__(self) -> Self: ...
    def __neg__(self) -> Self: ...
    def __add__(self, other: Self | int, /) -> Self: ...
    def __radd__(self, other: int, /) -> Self: ...
    def __sub__(self, other: Self | int, /) -> Self: ...
    def __rsub__(self, other: int, /) -> Self: ...
    def __mul__(self, other: Self | int, /) -> Self: ...
    def __rmul__(self, other: int, /) -> Self: ...
    def __truediv__(self, other: Self | int, /) -> Self: ...
    def __rtruediv__(self, other: int, /) -> Self: ...
    def __pow__(self, other: int, /) -> Self: ...
    def __rpow__(self, other: int, /) -> Self: ...


_Tscalar = TypeVar("_Tscalar", bound=scalar_p)


class poly_p(elem_p, Protocol[_Tscalar]):
    """FLINT univariate polynomial Protocol."""
    def str(
        self, ascending: bool = False, var: str = "x", *args: Any, **kwargs: Any
    ) -> str: ...
    def __iter__(self) -> Iterator[_Tscalar]: ...
    def __getitem__(self, index: int, /) -> _Tscalar: ...
    def __setitem__(self, index: int, value: _Tscalar | int, /) -> None: ...
    def __len__(self) -> int: ...
    def length(self) -> int: ...
    def degree(self) -> int: ...
    def coeffs(self) -> list[_Tscalar]: ...
    @overload
    def __call__(self, other: _Tscalar | ifmpz, /) -> _Tscalar: ...
    @overload
    def __call__(self, other: Self, /) -> Self: ... # pyright: ignore[reportOverlappingOverload]

    def __pos__(self) -> Self: ...
    def __neg__(self) -> Self: ...
    def __add__(self, other: _Tscalar | ifmpz | Self, /) -> Self: ...
    def __radd__(self, other: _Tscalar | ifmpz, /) -> Self: ...
    def __sub__(self, other: _Tscalar | ifmpz | Self, /) -> Self: ...
    def __rsub__(self, other: _Tscalar | ifmpz, /) -> Self: ...
    def __mul__(self, other: _Tscalar | ifmpz | Self, /) -> Self: ...
    def __rmul__(self, other: _Tscalar | ifmpz, /) -> Self: ...
    def __truediv__(self, other: _Tscalar | ifmpz | Self, /) -> Self: ...
    def __rtruediv__(self, other: _Tscalar | ifmpz, /) -> Self: ...
    def __floordiv__(self, other: _Tscalar | ifmpz | Self, /) -> Self: ...
    def __rfloordiv__(self, other: _Tscalar | ifmpz, /) -> Self: ...
    def __mod__(self, other: _Tscalar | ifmpz | Self, /) -> Self: ...
    def __rmod__(self, other: _Tscalar | ifmpz, /) -> Self: ...
    def __divmod__(self, other: _Tscalar | ifmpz | Self, /) -> tuple[Self, Self]: ...
    def __rdivmod__(self, other: _Tscalar | ifmpz, /) -> tuple[Self, Self]: ...
    def __pow__(self, other: int, /) -> Self: ...
    def is_zero(self) -> bool: ...
    def is_one(self) -> bool: ...
    def is_constant(self) -> bool: ...
    def is_gen(self) -> bool: ...
    def roots(self) -> list[tuple[_Tscalar, int]]: ...
    # Should be list[arb]:
    def real_roots(self) -> list[Any]: ...
    # Should be list[acb]:
    def complex_roots(self) -> list[Any]: ...
    def derivative(self) -> Self: ...


class epoly_p(poly_p[_Tscalar], Protocol):
    """FLINT exact univariate polynomial Protocol."""
    def sqrt(self) -> Self: ...
    def gcd(self, other: Self | _Tscalar, /) -> Self: ...
    def factor(self) -> tuple[_Tscalar, list[tuple[Self, int]]]: ...
    def factor_squarefree(self) -> tuple[_Tscalar, list[tuple[Self, int]]]: ...
    def deflation(self) -> tuple[Self, int]: ...


class mpoly_p(elem_p, Protocol[_Tctx, _Telem, _Telem_coerce]):
    """FLINT multivariate polynomial Protocol."""
    def __init__(
        self,
        val: Self
        | _Telem
        | _Telem_coerce
        | int
        | dict[tuple[int, ...], _Telem | _Telem_coerce | int]
        | str = 0,
        ctx: _Tctx | None = None,
    ) -> None: ...
    def str(self) -> _str: ...
    def repr(self) -> _str: ...
    def context(self) -> _Tctx: ...
    def degrees(self) -> tuple[int, ...]: ...
    def total_degree(self) -> int: ...
    def leading_coefficient(self) -> _Telem: ...
    def to_dict(self) -> dict[tuple[int, ...], _Telem]: ...
    def is_one(self) -> bool: ...
    def is_zero(self) -> bool: ...
    def is_constant(self) -> bool: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: tuple[int, ...]) -> _Telem: ...
    def __setitem__(
        self, index: tuple[int, ...], coeff: _Telem | _Telem_coerce | int
    ) -> None: ...
    def __iter__(self) -> Iterable[tuple[int, ...]]: ...
    def __contains__(self, index: tuple[int, ...]) -> bool: ...
    def coefficient(self, i: int) -> _Telem: ...
    def monomial(self, i: int) -> tuple[int, ...]: ...
    def terms(self) -> Iterable[tuple[tuple[int, ...], _Telem]]: ...
    def monoms(self) -> list[tuple[int, ...]]: ...
    def coeffs(self) -> list[_Telem]: ...
    def __pos__(self) -> Self: ...
    def __neg__(self) -> Self: ...
    def __add__(self, other: Self | _Telem | _Telem_coerce | int) -> Self: ...
    def __radd__(self, other: _Telem | _Telem_coerce | int) -> Self: ...
    def __sub__(self, other: Self | _Telem | _Telem_coerce | int) -> Self: ...
    def __rsub__(self, other: _Telem | _Telem_coerce | int) -> Self: ...
    def __mul__(self, other: Self | _Telem | _Telem_coerce | int) -> Self: ...
    def __rmul__(self, other: _Telem | _Telem_coerce | int) -> Self: ...
    def __truediv__(self, other: Self | _Telem | _Telem_coerce | int) -> Self: ...
    def __rtruediv__(self, other: _Telem | _Telem_coerce | int) -> Self: ...
    def __floordiv__(self, other: Self | _Telem | _Telem_coerce | int) -> Self: ...
    def __rfloordiv__(self, other: _Telem | _Telem_coerce | int) -> Self: ...
    def __mod__(self, other: Self | _Telem | _Telem_coerce | int) -> Self: ...
    def __rmod__(self, other: _Telem | _Telem_coerce | int) -> Self: ...
    def __divmod__(
        self, other: Self | _Telem | _Telem_coerce | int
    ) -> tuple[Self, Self]: ...
    def __rdivmod__(self, other: _Telem | _Telem_coerce | int) -> tuple[Self, Self]: ...
    def __pow__(self, other: _Telem | _Telem_coerce | int) -> Self: ...
    def __rpow__(self, other: _Telem | _Telem_coerce | int) -> Self: ...
    def iadd(self, other: _Telem | _Telem_coerce | int) -> None: ...
    def isub(self, other: _Telem | _Telem_coerce | int) -> None: ...
    def imul(self, other: _Telem | _Telem_coerce | int) -> None: ...
    def gcd(self, other: Self) -> Self: ...
    def term_content(self) -> Self: ...
    def factor(self) -> tuple[_Telem, Sequence[tuple[Self, int]]]: ...
    def factor_squarefree(self) -> tuple[_Telem, Sequence[tuple[Self, int]]]: ...
    def sqrt(self) -> Self: ...
    def resultant(self, other: Self, var: _str | int) -> Self: ...
    def discriminant(self, var: _str | int) -> Self: ...
    def deflation_index(self) -> tuple[list[int], list[int]]: ...
    def deflation(self) -> tuple[Self, list[int]]: ...
    def deflation_monom(self) -> tuple[Self, list[int], Self]: ...
    def inflate(self, N: list[int]) -> Self: ...
    def deflate(self, N: list[int]) -> Self: ...
    def subs(self, mapping: dict[_str | int, _Telem | _Telem_coerce | int]) -> Self: ...
    def compose(self, *args: Self, ctx: _Tctx | None = None) -> Self: ...
    def __call__(self, *args: _Telem | _Telem_coerce) -> _Telem: ...
    def derivative(self, var: _str | int) -> Self: ...
    def unused_gens(self) -> tuple[_str, ...]: ...
    def project_to_context(
        self, other_ctx: _Tctx, mapping: dict[_str | int, _str | int] | None = None
    ) -> Self: ...


class mpoly_context_p(
    elem_p, Protocol[_Tmpoly, _Telem_co, _Telem_coerce_contra]
):
    """FLINT multivariate polynomial context protocol."""
    def nvars(self) -> int: ...
    def ordering(self) -> Ordering: ...
    def gen(self, i: int, /) -> _Tmpoly: ...
    def from_dict(self, d: Mapping[tuple[int, ...], _Telem_coerce_contra], /) -> _Tmpoly: ...
    def constant(self, z: _Telem_coerce_contra, /) -> _Tmpoly: ...
    def name(self, i: int, /) -> str: ...
    def names(self) -> tuple[str]: ...
    def gens(self) -> tuple[_Tmpoly, ...]: ...
    def variable_to_index(self, var: str, /) -> int: ...
    def term(
        self, coeff: _Telem_coerce_contra | None = None, exp_vec: Iterable[int] | None = None
    ) -> _Tmpoly: ...
    def drop_gens(self, gens: Iterable[str | int], /) -> Self: ...
    def append_gens(self, gens: Iterable[str | int], /) -> Self: ...
    def infer_generator_mapping(
        self, ctx: flint_mpoly_context, /
    ) -> dict[int, int]: ...
    @classmethod
    def from_context(
        cls,
        ctx: _Sctx,
        names: str | Iterable[str | tuple[str, int]] | tuple[str, int] | None = None,
        ordering: Ordering | str = Ordering.lex,
    ) -> _Sctx: ...


class series_p(elem_p, Protocol[_Telem]):
    """FLINT univariate power series."""

    def __iter__(self) -> Iterator[_Telem]: ...
    def coeffs(self) -> list[_Telem]: ...


if TYPE_CHECKING:

    _x1: scalar_p = _flint.fmpz(1)
    _x2: scalar_p = _flint.fmpq(1, 2)
    _x3: scalar_p = _flint.nmod(1, 2)
    _x4: scalar_p = _flint.fmpz_mod(1, _flint.fmpz_mod_ctx(2))
    _x5: scalar_p = _flint.fq_default(1, _flint.fq_default_ctx(2))
    # XXX: Add arf, acf, arb, acb, ...

    _y1: poly_p[_flint.fmpz] = _flint.fmpz_poly([1, 2])
    _y2: poly_p[_flint.fmpq] = _flint.fmpq_poly([1, 2])
    _y3: poly_p[_flint.nmod] = _flint.nmod_poly(1, 2)
    _y4: poly_p[_flint.fmpz_mod] = _flint.fmpz_mod_poly(1, _flint.fmpz_mod_poly_ctx(2))
    _y5: poly_p[_flint.fq_default] = _flint.fq_default_poly(1, _flint.fq_default_poly_ctx(2))
    # XXX: Add arb_poly, acb_poly, ...

    _z1: epoly_p[_flint.fmpz] = _flint.fmpz_poly([1, 2])
    _z2: epoly_p[_flint.fmpq] = _flint.fmpq_poly([1, 2])
    _z3: epoly_p[_flint.nmod] = _flint.nmod_poly(1, 2)
    _z4: epoly_p[_flint.fmpz_mod] = _flint.fmpz_mod_poly(1, _flint.fmpz_mod_poly_ctx(2))
    _z5: epoly_p[_flint.fq_default] = _flint.fq_default_poly(1, _flint.fq_default_poly_ctx(2))
